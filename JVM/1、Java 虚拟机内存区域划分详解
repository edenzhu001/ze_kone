背景：
  java virtual machine ，JAVA虚拟机，是运行class的程序。
  
  java代码经过java编译器，编译成class文件，一种与平台无关的代码格式。class文件按照JVM规范，包括了java代码运行时需要的元数据和代码等内容。
  jvm加载class文件后，就可以执行java代码了。
  
  加载器
  运行时数据区
  执行器
  
  
  一、概述
    
    C和C++的开发人员，在内存管理领域，拥有绝对的使用权，要做到正确的使用和清理内存。
    
    而JVM已经帮java开发人员做了这个事情，内存的合理分配和内存的有效及时回收，自动内存管理机制。
    但是出现了jvm出现了内存泄漏和内存溢出，也许要开发人员去了解。
    
 二、java运行时内存分区数据区域
    
    2部分：
        
        JVM管理：
        —————————————————————————————————————————————
        |  线程私有： 虚拟机栈、本地方法栈、程序计数器 |
        |  线程共享：内存堆(Heap,GC堆)、方法区        |
        _____________________________________________
        
        JVM外面：
        —————————————————————————————————————————————
        |  元数据 |   直接内存                       |
        —————————————————————————————————————————————
    1.程序计数器
        一块很小的内存，可以看做是当前线程所执行的字节码的行号指示器。
        线程私有，所以每个线程都有自己的程序计数器，也可以看做是线程的身份证。
        
        作用：(1)因为他是字节码的行号指示器，所以在字节码解释器经过改变计数器的值来选取下一行读取字节码，完成代码流程执行。
             (2)在多线程环境下，程序计数器可以记住当前线程执行的行号，等待线程恢复时，可以继续从这个行号执行字节码。
               
    2.虚拟机栈
      java虚拟机栈也是线程私有，和线程生命周期有关。为虚拟机执行java方法服务。
      
      虚拟机栈描述的是Java方法执行的内存模型。
      每个方法在被执行的时候，同时会创建栈帧用于存放的是 每个方法的局部变量表、操作栈、方法出口等。
      局部变量表所需的内存空间在编译期间完成分配。
      
      所以 基本数据类型(boolean char int short long double float byte)
      和引用类型 (可能是一个指向对象地址的引用指针，也有可能是指向一个代表对象的句柄)
      
      报错：线程请求的栈深度超过虚拟机栈所允许的深度，StackOverflowError；
           当可以动态扩展时，无法申请 到足够的内存时会跑出OutOfMemoryError
         
    3.本地方法栈
      这个地方比较简单。
      它主要是保存调用其他语言的方法接口，调用native方法。
      它是为虚拟机调用native方法服务的。
      
    4.java堆
      这是一个java虚拟机管理中最大的一块内存。
      Java堆是线程共享的，在虚拟机启动时创建的。
      
      唯一作用或目的就是存放对象实例。
      
      所以，java堆也是垃圾收集器的主要区域。也称为GC堆(Garbage Collected Heap)。
      从回收角度来说，GC算法是分代收集算法。堆中分为：新生代(Eden空间 From Survivor空间 To Survivor空间)、老年代。
      
      报错：如果堆中没有内存完成实例分配，堆也无法拓展时，会跑出OOM
      
    5.方法区
      它和java堆一样也是线程共享区域。
      java虚拟机规范对这片区域管理松散，可以选择不实现垃圾收集机制。
      
      它里面存放是类的信息、常量、静态变量等等。
      
      方法区是JVM的一种规范定义，永久代是一种实现，它是hotspot虚拟机对方法区的一种实现。可能其他虚拟机对方法区是另一种实现。
      
      【运行时常量池】也是方法区的一部分。方法区中处理有类的版本、字段、方法信息以外，还有常量池，用于存放编译期生成的各种字面量和符号引用。
      
      这个方法区概念 在java1.8就被移除了，使用元空间取代。
      
      为什么要替代呢？
      永久代有一个JVM本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，不会得到OOM异常。MetaSpace将根据运行时
      的应用程序需求动态调整大小。
      
    6.直接内存
    
      直接内存 Direct Memory 并不是JVM运行时数据区的一部分。它不归虚拟机管理。
      但是这部分内存被频繁的使用，可能导致OOM。
      
      NIO类引入一种 通道和换冲的方式，可以使用native方法来分配堆外内存，在堆中有个DirectByteBuffer对象作为分配内存的引用来进行操作。
      
      这个直接内存肯定是受限于本机内存，动态扩展时会出现OOM异常。
      
      
      上述的还有很多疑点：
      
      虚拟机栈 存放的具体是啥？
      对象的引用指针和指向句柄的指针？
      java堆的GC算法？分代收集算法以及具体的内存区域划分
      
      
