通过上一节，我们大概了解了虚拟机的内存情况，现在来了解一下java对象的探秘。


一、对象的创建
  有5步，要求必须能默写，能记住每一步都在做什么。
  
  假设有个Student类：Student s = new Student();
  
  (1)类加载检查——>(2)分配内存————>(3)初始化零值—————>(4)设置对象头——————>(5)执行init方法
  
  Step1:
    当虚拟机遇到一条new指令时，首先去检查这个class文件是否符合JVM要求。检查这个指令的参数是否能在常量池中定位到这个类的符号引用，
    并检查这个符号引用代表的类是否已被加载过、解析过、初始化过。 加载-验证-解析-初始化(Clinic)
    如果没有，那就先执行相应的类加载过程。
  Step2:
    虚拟机为新生对象分配内存。
    内存大小在类加载完成后可以确定。这个步骤就是把一块确定大小的内存从java堆中划分出来。
    
    分配方式有2种：指针碰撞和空闲列表
    
    堆内存规整：已使用的内存在一边，未使用的内存在一边。
    
    堆内存不归整：已使用的内存和未使用内存相互交错
    
    当内存绝对规整时，内存分配使用【指针碰撞】->
                      分配形式：(1)已使用的内存在一边，未使用的内存在一边，中间放一个作为分界点的指示器。
                               (2)分配对象内存=把指针向未使用的内存移动一段与对象大小相等的距离。
                               如图：
                               
    当堆内存不归整时，内存分配使用【空闲列表】->
                     分配形式：虚拟机维护着一个记录可用内存块的列表，在分配时从列表中找到一块足够大的空间划分给对象实例，
                              并更新列表上的记录
    
    选择哪种由java对是否规整，取决于GC收集器的算法是 "标记-清除"还是"标记-整理"；注意一下，复制算法内存也是规整的。
    
    带Compact过程的垃圾收集器，内存绝对规整，采用指针碰撞。比如：Serial,ParNew垃圾收集器
    
    基于Mark_sweep算法的垃圾收集器，采用空闲列表。比如：CMS垃圾收集器。
    
  
    内存分配并发问题：
        创建对象时有个很重要的问题就是线程安全。现实中对象的创建很频繁。
        采用2种方式来保证线程是安全的。
        CAS+失败重试：
            CAS是乐观锁的一种实现方式。
        TLAB：
            为每一个线程预先在Eden区域分配一块内存，这块内存叫做TLAB(Thread Local Allocation Buffer线程本地分配缓存)，
            JVM在给线程中的对象分配内训时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已经用尽时，再采用上述CAS+失败重试进行内存分配。
   
  Step3:
    初始化零值，在内存分配完成后，需要将内存空间分配0值(不包括对象头)，这个操作保证了对象的实例字段在java代码中不赋值就直接使用。
    程序可以访问这些字段属性的0值。
    
  Step4:
    设置对象头。
    初始化零值完成后，虚拟机需要对 对象进行必要的设置。
    比如对象时哪个类的实例，对象的哈希码，对象GC分代年龄等等
    
  Step5:
    执行init方法。
    在jvm看来这个对象已经生成。但是从java程序看来，对象创建才刚开始。init方法可以把对象按照开发者的意愿进行初始化。
    这init方法是程序执行  调用对象的构造方法方法才会执行init方法。
    
    在第一步类加载检查中有个clinit方法，这个是类构造器方法。
    
    这样真正的对象才算是完全产生出来。
