线程复用：线程池

一、概念
线程池可以看做是线程的集合。没有任务时，线程就处于空闲状态。当有任务进来，线程池会给这个任务分配一个空闲线程，
完成任务之后，这个线程会回到线程池中等待下一次的任务安排。这样就实现了线程的复用或重用。

为什么要用线程池？反向思考：为每个请求开新的线程是可以的，但是有弊端。
1.线程生命周期的开销非常高。
[线程的创建和销毁所花费的时间可能比业务处理还要花更多时间或占用更多资源]
2.程序的健壮性和稳定性会下降，或者说性能下降。
[为每个请求开线程，如果请求量过大或遭受恶意攻击，很容易内存不足，资源不够用，导致程序奔溃]

所以，用线程池。要用就线程池分配空闲线程，用完了，就把该线程返还到线程池中。如果线程不够用，就排队等待。

二、线程生命周期

                新建状态
                  |
                  |--调用start()
                  |
———————————————>就绪状态(堵塞条件取消后，重新进入就绪状态，等待CPU资源)<————————————————————————————
|                 |                                                                           |
|--yield()        |--系统调度，获取到cpu时间                                                 阻塞状态          
|                 |                                                                           |                        
<———————————————运行状态———————————————————————————————————————————————————————————————————————>
                  |
                  |运行run()方法完毕
                  |
                死亡状态
  新建状态：线程创建状态，调用start()方法，进入 就绪状态。
  就绪状态：线程等待CPU的资源就是就绪。 来由：可以是由新建刚刚到就绪，也可以是阻塞条件刚刚取消，重新进入就绪状态。反正都是等待CPU的资源。
  运行状态：线程获得CPU调度和时间安排，执行run()方法，就是运行状态。来由：由就绪状态到运行状态，线程获取到了cpu时间。
  死亡状态：run()方法执行完毕。正常终止，执行完所有的工作，正常结束。强制终止，调用stop方法或destroy()。系统异常，线程执行过程中发生异常。
  
  阻塞状态：正在执行的线程因为某些原因被阻塞，暂时主动让出CPU资源。
           来由：由运行状态过来到阻塞状态【1.调用时间限制或非时间限制的wait() sleep()方法 2.等待锁、I\O 】
           去向：有阻塞状态过去到就绪状态【1.sleep wait()的时间到了 2.notify() 3.I\O结束，资源准备完成】
           
  注意：yield（）方法可以让当前处于运行状态的线程转入就绪状态
  
  三、JDK对线程池的支持
  
  
  
