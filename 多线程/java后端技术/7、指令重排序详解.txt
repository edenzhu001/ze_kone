指令重排序

1.数据依赖性
  如果有两个操作对同一个变量, 并且其中至少一个操作有写的操作, 此时这两个操作就存在数据依赖性. 
  数据依赖性 有3种: 
  名称   |  代码        | 说明
  写后读 | a = 1;b = a; | 写一个变量之后，再读这个位置。 |
  写后写 | a = 1;a = 2; | 写一个变量之后，再写这个变量。 |
  读后写 | a = b;b = 1; | 读一个变量之后，再写这个变量。 |
  
  这3中情况,只要重排序两个操作的执行顺序，程序的执行结果将会被改变. 
  编译器和处理器可能会对操作做重排序. 编译器和处理器在重排序时, 会遵守数据依赖性(编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序). 
  
  强调: 这里说的数据依赖性只是针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。
  因此, 多线程下, 重排序不会遵守数据依赖性. 
  
  as-if-serial 语义
  意思是：无论怎么重排序(编译器和执行器为了提高并行指令),单线程程序执行的结果不能被改变. 编译器，runtime 和处理器都必须遵守 as-if-serial 语义。
  
  如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：
  double pi  = 3.14;    //A
  double r   = 1.0;     //B
  double area = pi * r * r; //C
  依赖关系如图 rela_01.png
  如图：A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。
  因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。
  但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。
  
  可能存在的2种程序顺序执行,如图rela_02.png
  A -> B -> C 或 B -> A -> C
  单线程下, 遵循as-if-serial, C的结果不会变, 所以 无论是上述哪种顺序, 程序员都会认为是按照自己的代码顺序执行的命令.

2.程序顺序规则
在上述的计算圆面积的代码中, 有3个happens-before关系.
A happens- before B；
B happens- before C；
A happens- before C；
在重排序操作和happens-before关系操作的结果一致,JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。

3.重排序对多线程的影响
4.编译器重排序
5.指令集并行的重排序
6.内存系统的重排序
7.memory barrier
8.JDK 1.7 内存屏障实现

参考资料：https://www.jianshu.com/p/c6f190018db1
