上一篇说的, 线程间通信和同步用wait、notify必须要结合synchronized使用. 

下面有种更为简单的方式, 请记住Lock对象.

一、简介
  Lock接口->ReentrantLock类. Lock类说的就是Lock的实现类.
  
  ReentrantLock实现线程同步
      import java.util.concurrent.locks.Lock;
      import java.util.concurrent.locks.ReentrantLock;

      public class RunTest {
          public static void main(String[] args) {
              Lock lock = new ReentrantLock(); //lock对象

              new Thread(() -> {
                  runMethod(lock);
              }, "t1").start();

              new Thread(() -> {
                  runMethod(lock);
              }, "t2").start();

              new Thread(() -> {
                  runMethod(lock);
              }, "t3").start();

              new Thread(() -> {
                  runMethod(lock);
              }, "t4").start();

              new Thread(new Runnable() {
                  @Override
                  public void run() {
                      runMethod(lock);
                  }
              }, "t5").start();
          }

          public static void runMethod(Lock lock) {
              lock.lock();  // 同步锁启动
              for (int i = 0; i <= 5; i++) {
                  System.out.println("threadname" + Thread.currentThread().getName() + "; i=" + i);
              }
              System.out.println();
              lock.unlock(); //同步锁结束
          }
      }
      结果：threadnamet1; i=0
            threadnamet1; i=1
            threadnamet1; i=2

            threadnamet2; i=0
            threadnamet2; i=1
            threadnamet2; i=2

            threadnamet4; i=0
            threadnamet4; i=1
            threadnamet4; i=2

            threadnamet3; i=0
            threadnamet3; i=1
            threadnamet3; i=2

            threadnamet5; i=0
            threadnamet5; i=1
            threadnamet5; i=2
      解析：很明显, 当前线程打印完成之后才释放锁, 其他线程才能够获取到锁然后进行打印. 必须得当前线程完全执行完才会释放. 
      释放后, 剩下的线程竞争争夺锁.
      
      进一步了解Lock实现同步：
        import java.util.concurrent.locks.Lock;
        import java.util.concurrent.locks.ReentrantLock;

        public class RunTest {
            public static void main(String[] args) {
                Lock lock = new ReentrantLock();

                System.out.println("开始："+System.currentTimeMillis());
                new Thread(() -> {runMethod(lock,0);}, "t1").start();

                new Thread(() -> {runMethod(lock,5000);}, "t2").start();

                new Thread(() -> {runMethod(lock,1000);}, "t3").start();

                new Thread(() -> {runMethod(lock,3000);}, "t4").start();

                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        runMethod(lock,2000);
                    }
                }, "t5").start();
            }

            public static void runMethod(Lock lock,long sleepTime) {
                lock.lock();
                try {
                    Thread.sleep(sleepTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("threadname" + Thread.currentThread().getName());
                lock.unlock();
            }
        }
        结果：
        开始：1569240308399
        threadnamet1
        threadnamet2
        threadnamet3
        threadnamet4
        threadnamet5
        
        解析：有明显的时间间隔, 在sleep指定的时间内，当调用了lock.lock()方法线程就持有了”对象监视器”，
        其他线程只能等待锁被释放后再次争抢，效果和使用synchronized关键字是一样的. 
        
   二、使用Lock对象实现线程间通信

      在上一篇我们知道synchronized+wait/notify实现线程间的通信, 也就是等待/通知模式.
      现在通过ReentrantLock、Condition对象实现的. 
      
      Condition的创建方式：
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
       
       
