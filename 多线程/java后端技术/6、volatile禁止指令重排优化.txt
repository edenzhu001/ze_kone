一、volatile的作用详解

在升级版本的线程安全的懒汉单例模式中, 如下, 
  
  public volatile Singleton s = null;
  public Singleton getInstance(){
    if (s == null){
      synchronized (****.class){
        if(s == null){
          s = new Singleton();
        }
      }
    }
    return s;
  }
  
  synchronized给同步方法块加锁, volatile则是使得变量对所有线程可见, 并且禁止对其进行指令重排序优化。
  
  今天详细说的就是volatile的作用. 
  
  首先, instance = new Singleton();
  这个创建实例的过程分为：(1)分配内存空间, 设置默认值 (2)调用构造方法初始化对象 (3)将对象的内存地址赋给instance引用. 
  指令重排序优化 就会导致【初始化单例对象】和【对象地址赋值给instance】 顺序颠倒, 造成return的结果还是没初始化完全, 出现系统异常. 
  
  提出疑问, 平时A a = new A(); 重排序优化为什么不出问题？
  解答：平时的new出对象实例都是在单线程下，指令重排序优化不会出现上述问题. 
  
  volatile关键字修饰instance的作用除了禁止重排序优化以外, 
  还有一个重要作用就是提供内存可见性(工作内存->主内存), 保证其他线程知道该变量.

  volatile为什么可以实现禁止？什么是指令重排序优化？
  (1)指令重排序是JVM为了优化代码指令, 提高程序运行效率, 在不影响单线程程序执行结果的前提下, 尽可能提高程序并行度(多条指令并行执行或是调整指令的运行顺序). 
  编译器 和 处理器 都遵循这个原则. 强调, 在单线程 和单个处理器时, 遵守这一原则. 
  所以, 单线程不会有问题, 多线程才有问题出现. 
  
  (2)正是指令重排序 在多线程下会程序的执行顺序会有颠倒, 所以才会需要volatile来禁止指令重排序优化. 
  而且, volatile保证变量在多个线程的可见性. 
  
  (3)volatile关键字就是将该线程操作的变量值 迅速从该线程的工作内存中读取写入到主内存中, 供其他线程可见到该变量的值.
  图示, volatile_varialble.png
  
  
  
