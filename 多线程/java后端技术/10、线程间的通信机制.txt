
前言
  大家都知道 线程是分配cpu的最小单位, 独立的个体. 为了提高cpu的利用率和线程间的协作, java中一种实现线程间通信的机制 wait() notify().
  
1.等待/通知机制
  去吃饭等位就是一个场景. 拿到号之后 需要 等待, 排到了, 就通知去入位.
  
2.实现
  java中等待/通知方法是wait()和notify()方法, 这两个方法都是超类Object的方法.  因为前面说过任何对象都可作为锁. 
  
  wait()方法：
  (1)作用：使得当前执行代码的线程进行等待, 该方法会将该线程放入"预执行队列"中, 并且在wait()所在的代码处停止执行, 知道被通知或中断为止.
  
  (2)在调用wait()方法之前, 线程必须获得该对象级别锁. 即, 只能在同步方法或同步方法块中调用wait().
  
  (3)wait()是释放锁的, 即在执行到wait()方法之后，当前线程会释放锁，当从wait()方法返回前，线程与其他线程竞争重新获得锁。[理解: 当当前线程wait()时, 
  该资源就可以被其他线程访问, 这个过程也就是说明, 当前线程放弃锁, 让别的线程获取. ]
  
  notify()方法：
  (1)notify()方法也要在同步块或同步方法中调用，即在调用前，线程也必须获得该对象的对象级别锁。
  
  (2)是用来通知那些可能等待该对象的对象锁的其他线程, 如果有多个线程等待, 则由线程规划器随机挑选出其中一个呈wait状态的线程，
  对其发出通知notify，并使它等待获取该对象的对象锁. 
  
  (3)这里需要注意的是，执行notify方法之后，当前线程不会立即释放其拥有的该对象锁，而是执行完之后才会释放该对象锁，
  被通知的线程也不会立即获得对象锁，而是等待notify方法执行完之后，释放了该对象锁，才可以获得该对象锁。[???]
  
  (4)notifyAll()通知所有等待同一共享资源的全部线程从等待状态退出，进入可运行状态，重新竞争获得对象锁。
  
  总结：
  （1）wait()/notify()要集合synchronized关键字一起使用，因为他们都需要首先获取该对象的对象锁；

  （2）wait方法是释放锁，notify方法是不释放锁的；
  
   (3) 线程生命周期如图thread_life.png
   
