这篇笔记围绕以下几点来阐述：
  为什么使用redis?
  使用redis的优缺点?
  单线程的redis怎么这么快?
  Redis的数据类型以及每种数据类型的应用场景
  Redis的过期策略以及内存淘汰机制
  Redis和数据库双写一致性问题
  应对缓存穿透和缓存雪崩问题
  如何解决Redis的并发竞争key问题
  
 一、为什么使用Redis?
  应该是从性能和并发去考虑。
   1.性能->有时候我们需要去查询数据库，而且这种查询很频繁，耗时长，且结果变动不大的SQL,特别适合将运行结果放入缓存中。后面的请求就从缓存中读取，快速。
   2.并发->在大并发情况下，所有的请求都打到数据库。明显数据库支撑不住。所以，此时的redis相当于是个缓冲操作。可以把一部分的请求在缓存上就完成，
   而不是直达数据库。
   
   
 二、redis使用的缺点
  主要是4个问题：
    缓存和数据库的读写一致性问题
    缓存雪崩问题
    缓存击穿问题
    缓存的并发竞争问题
    
 三、单线程的redis为什么这么快？
   回答是3点：
    1.纯内存操作
    2.单线程操作，避免频繁的上下文切换
    3.采用了非阻塞I/O多路复用机制
    
    解释：(1)Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快
         (2)上下文切换是指CPU从一个线程切换到另一个线程。
            在这操作中，需要记录程序计数器当前线程执行到哪行代码了，也许需要记录当前线程中计算的一些变量值寄存器操作等等操作。
         (3)非阻塞IO多路复用：
            简单来说就是redis-client在操作的时候会产生不同事件类型的Socket。
            在服务端就有一段IO复用程序，将其置入队列中。单线程依次去处理socket请求。
            多路就是多个请求，复用就是用重复用单线程去处理请求。
            线程池 其实也是线程的复用。为了避免线程的创建浪费资源，所以设置线程池来处理队列中的任务。

 四、Redis的数据类型和每种数据类型的使用场景
      String 
        常规的get/set类型。可以用作复杂的计数缓存。
      Hash
        存放的是结构化对象。单点登录时可以存储一些用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间。
      List
        list数据结构。可以用作消息队列，也可以利用list的范围获取元素，来实现分页功能。
      Set
        set可以放一些不重复的值的集合。所以可以做去重操作。同时交集 并集 差集操作，可以用作共同兴趣爱好 共同好友等
      Zset
        和set一样，只是多了个score分值权重。可以用作排序操作，排名等。
 
 五、Redis的过期策略以及内存淘汰机制
      内存中的数据清理?
      Redis采用的是定期删除+惰性删除策略。
      
      为什么不用定时删除?
      定时删除，需要用一个定时器来监视key，过期则自动删除。这样十分消耗资源。 Redis应该尽可能的将资源放到处理请求上，而不是删除Key。
      
      定期删除+惰性删除
      (1)定期删除【随机抽取进行检查】。
        默认每100ms进行检查一次，随机抽取进行检查。
      (2)惰性删除【有请求获取key】
        在客户端去请求获取某个key的时候，redis检查一下。若是设置并且过了过期时间，则删除。
        
       但是，同样解决不了问题。因为总有漏网之鱼的key，既没有被随机抽取到，则没有被请求到，一直存在内存中。
       
       此时，内存淘汰机制上场。经常使用的是移除最近最少使用的key。
          从是否设置过期时间来分类：
            否：从普通的键空间中，可以移除最近最少使用的key，随机移除，写入报错(不删除)
            是：从过期的键空间中，可以移除随机选取key,可以移除最近最少使用的key
            
  六、Redis和数据库双写一致问题
      一致性问题是分布式常见问题，还可以分为最终一致性和强一致性。
      
      缓存和数据库的双写 肯定会出现不一致问题。
      
      回答：首先，采用正确更新更新策略，先更新数据库，再删除缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可。
      
  七、如何应付缓存穿透和缓存雪崩
    
      缓存穿透，即黑客去故意去请求缓存中不存在的数据，从而导致请求打到数据上，造成异常。
    
      解决方案：
        (1)利用互斥锁，缓存失效，先去获取锁 ，再去请求数据库。没有获取到就排队等待。
        (2)提供一个能迅速判断请求是否有效的拦截机制。布隆过滤器，维护一系列合法有效的key。不合法的key直接返回。
        (3)异步更新缓存策略
    
      缓存雪崩，即缓存同一时间大面积失效，此时又来了一大波请求，直接打到数据库，导致异常。
      解决方案：
        (1)给缓存设置随机失效时间
        (2)双缓存配置。缓存A失效时间为20分钟，缓存B不做失效时间。自己做缓存预热处理。
           请求一般打到缓存A,A若没有，则请求缓存B,并启动异步线程去更新缓存A和缓存B。
    
   八、如何解决Redis并发竞争key问题
      多个子系统同时去set同一个key值。
      
      如果不要求顺序，则添加个分布式锁，抢到锁就执行set命令。
      
      如果要求顺序，就用个时间来判断操作。
  
  
            
      
 
      
