本文围绕以下几点来对redis加深了解...重中之重：redis可以设置超时时间。老是忘记。
  
    1.为什么使用 Redis
    2.使用 Redis 有什么缺点
    3.单线程的 Redis 为什么这么快
    4.Redis 的数据类型，以及每种数据类型的使用场景
    5.Redis 的过期策略以及内存淘汰机制
    6.Redis 和数据库双写一致性问题
    7.如何应对缓存穿透和缓存雪崩问题
    8.如何解决 Redis 的并发竞争 Key 问题
    
 一、为什么使用redis
    在项目中使用redis，从2个角度考虑：性能和并发。分布式锁也可以，但是分布式锁也可以用zookpeer。
    所以回答这个问题，主要是性能和并发。
    
    1.性能
        如果遇到需要执行耗时特别久的，且查询结果不会频繁变动的SQL，特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，响应会很快。
        
    2.并发
        在大并发的情况下，所有的请求直接访问数据库，数据库会出现链接异常。
        
        这时，就需要Redis来做一个缓冲，让请求先访问到Redis，而不是直接访问数据库。
        
二、Redis有什么缺点
    
    显然，Redis用作缓存的话。缓存和数据库出现不一致，这就是问题。
    
    缓存和数据库双写一致性问题
    缓存雪崩
    缓存击穿
    缓存并发竞争
    
    后文附解决方案。
    
三、单线程的redis为啥这么快
    (1)内存操作，k-v类似于hahmap ,搜索和操作的时间复杂度都是O(1)
    (2)简单的数据结构
    (3)单线程 避免上下文切换，多进程多线程的切换需要消耗CPU，多线程还要考虑上锁，死锁会导致性能消耗等等
    (4)采用非阻塞IO的多路I/O复用模型
    
四、Redis的数据类型 以及使用场景
    String ->
            set/get 。也可以是数字，所以场景就是复杂的计数功能的缓存。incr命令。
            
    Hash -> 
          这里的value是结构化的对象。
          hset/hget 
          场景：比例时候存放用户信息，用作单点登录。还可以设置缓存失效时间。setnx。
          
    list -> 
          存放列表结构的数据。
          lpush/linsert
          场景：简单消息队列，lrange 还可以做分页功能
     
     set -> 
          Set集合是存放一堆不重复的元素集合。
          sadd/srem
          支持 交集 并集 差集计算。
          场景：共同好友 共同兴趣爱好
          
     set -> 
          zset是有序的不重复的集合。其中有重要的分数也就是权重score。能够按照分值排序。
          zadd/zrem
          这个就很好说了，排名，微信步数
          
五、Redis 的过期策略以及内存淘汰机制
    抛出问题：
        比如Redis只能存5G数据，而你写了10G，那会删除5G，怎么删？
        如果设置了过期时间，当时间到了时，内存占用率还是比较高，怎么搞？
    
    回答：
        定期删除+惰性删除策略
        
    1.没有定时删除策略
        定时删除，需要起定时任务来负责监视key，过期就自动删除。这样十分消耗CPU资源。
        
        在大并发情况下，CPU应该将更多的时间应用在处理请求上，而不是删除key。所以没有定时删除策略
    
    2.定期删除+惰性删除是如何工作
        
        定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。
                 说明，Redis不是每个100ms检查所有的key，而是随机进行抽取。
                 那还有没有检查到的怎么搞？
        惰性删除，某个键值过期后，此键值不会马上被删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。
                 所以惰性删除的缺点很明显:浪费内存
                 
        定期删除+惰性删除也有问题->肯定存在随机中未被抽查而且很久没有用过的过期key-value，Redis的内存会越来越高。
        How to do ?
        
        那么就应该采用内存淘汰机制。
            noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
            
            【allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。】
            
            allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
            
            volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。
            
            volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
            
            volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。
            
   六、Redis 和数据库双写一致性问题
        
        
        
        

        
        
        
    
   
          
          
