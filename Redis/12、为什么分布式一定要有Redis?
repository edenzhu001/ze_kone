本文围绕以下几点来对redis加深了解...重中之重：redis可以设置超时时间。老是忘记。
  
    1.为什么使用 Redis
    2.使用 Redis 有什么缺点
    3.单线程的 Redis 为什么这么快
    4.Redis 的数据类型，以及每种数据类型的使用场景
    5.Redis 的过期策略以及内存淘汰机制
    6.Redis 和数据库双写一致性问题
    7.如何应对缓存穿透和缓存雪崩问题
    8.如何解决 Redis 的并发竞争 Key 问题
    
 一、为什么使用redis
    在项目中使用redis，从2个角度考虑：性能和并发。分布式锁也可以，但是分布式锁也可以用zookpeer。
    所以回答这个问题，主要是性能和并发。
    
    1.性能
        如果遇到需要执行耗时特别久的，且查询结果不会频繁变动的SQL，特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，响应会很快。
        
    2.并发
        在大并发的情况下，所有的请求直接访问数据库，数据库会出现链接异常。
        
        这时，就需要Redis来做一个缓冲，让请求先访问到Redis，而不是直接访问数据库。
        
二、Redis有什么缺点
    
    显然，Redis用作缓存的话。缓存和数据库出现不一致，这就是问题。
    
    缓存和数据库双写一致性问题
    缓存雪崩
    缓存击穿
    缓存并发竞争
    
    后文附解决方案。
    
三、单线程的redis为啥这么快
    (1)内存操作，k-v类似于hahmap ,搜索和操作的时间复杂度都是O(1)
    (2)简单的数据结构
    (3)单线程 避免上下文切换，多进程多线程的切换需要消耗CPU，多线程还要考虑上锁，死锁会导致性能消耗等等
    (4)采用非阻塞IO的多路I/O复用模型
    
四、Redis的数据类型 以及使用场景
    String ->
            set/get 。也可以是数字，所以场景就是复杂的计数功能的缓存。incr命令。
            
    Hash -> 
          这里的value是结构化的对象。
          hset/hget 
          场景：比例时候存放用户信息，用作单点登录。还可以设置缓存失效时间。setnx。
          
    list -> 
          存放列表结构的数据。
          lpush/linsert
          场景：简单消息队列，lrange 还可以做分页功能
     
     set -> 
          Set集合是存放一堆不重复的元素集合。
          sadd/srem
          支持 交集 并集 差集计算。
          场景：共同好友 共同兴趣爱好
          
     set -> 
          zset是有序的不重复的集合。其中有重要的分数也就是权重score。能够按照分值排序。
          zadd/zrem
          这个就很好说了，排名，微信步数
          
五、Redis 的过期策略以及内存淘汰机制
    抛出问题：
        比如Redis只能存5G数据，而你写了10G，那会删除5G，怎么删？
        如果设置了过期时间，当时间到了时，内存占用率还是比较高，怎么搞？
    
    回答：
        定期删除+惰性删除策略
        
    1.没有定时删除策略
        定时删除，需要起定时任务来负责监视key，过期就自动删除。这样十分消耗CPU资源。
        
        在大并发情况下，CPU应该将更多的时间应用在处理请求上，而不是删除key。所以没有定时删除策略
    
    2.定期删除+惰性删除是如何工作
        
        定期删除，Redis 默认每个 100ms 检查，是否有过期的 Key，有过期 Key 则删除。
                 说明，Redis不是每个100ms检查所有的key，而是随机进行抽取。
                 那还有没有检查到的怎么搞？
        惰性删除，某个键值过期后，此键值不会马上被删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。
                 所以惰性删除的缺点很明显:浪费内存
                 
        定期删除+惰性删除也有问题->肯定存在随机中未被抽查而且很久没有用过的过期key-value，Redis的内存会越来越高。
        How to do ?
        
        那么就应该采用内存淘汰机制。
            noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。
            
            【allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。推荐使用，目前项目在用这种。】
            
            allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。应该也没人用吧，你不删最少使用 Key，去随机删。
            
            volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。不推荐。
            
            volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。依然不推荐。
            
            volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。不推荐。
            
   六、Redis 和数据库双写一致性问题
       一致性问题是分布式常见问题，还可以再分为【最终一致性】和【强一致性】。数据库和缓存双写，就必然会存在不一致的问题。

      答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。

      另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。

      回答：首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。
      
      
   七、如何应对缓存穿透和缓存雪崩问题
        
        缓存穿透：黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
              
              解决方案：
                      (1)利用互斥锁。
                      
                      (2)采用异步更新策略，无论key是否取到值，都直接返回。
                          value值中维护一个缓存失效的时间，缓存如果失效，异步起线程去读数据库，更新缓存。
                          需要做缓存预热(项目启动前，先加载缓存)。
                          
                      (3)提供一个迅速判断请求是否有效的拦截机制。
                            布隆过滤器，内部维护一系列合法有效的key。
                            
        缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
             大批的key-value设置的失效时间相近。
             解决方案：
                    (1)给缓存的失效时间，加上随机值，避免集体失效
                    (2)使用互斥锁
                    (3)双缓存
                        设置2个缓存，缓存A和缓存B。
                        缓存A设置20分钟，缓存B不设置失效时间。自己做缓存预热。
                        细分：从缓存A读数据时，有则直接返回；A没有就直接从缓存B中读取数据，直接返回，并且异步启动一个更新线程，更新线程
                        同事更新缓存A和缓存B。
                        
    八、如何解决 Redis 的并发竞争 Key 问题
    
        大致就是，同时有多个子系统去 Set 一个 Key。这个时候大家思考过要注意什么呢？
        
        假设有一个key1，系统A设置value为valueA，系统B设置value为valueB，系统C设置value为valueC。
        
        不采用redis事务机制，原因：一个事务中可能有多个key操作，多个key不一定都存储在同一个redis-server上，
        所以此时Redis的事务机制无效。
        
        解决1：如果不考虑，赋值的顺序。
            可以设置一个分布式锁，某个请求抢到锁就去set即可。
            
        解决2：如果考虑时间顺序。
            那么在写入redis时，需要加上保存一个时间戳。
            假设时间戳如下：
                系统A key1  {vlaueA 3:00}
                系统B key1  {vlaueB 3:05}
                系统C key1  {vlaueC 3:10}
                
            此时，假设系统B先抢到锁，将key1 vlaueB 3:05 set到redis中。接下来，系统A抢到锁发现自己的valueA 的时间比redis中的早，
            那么就不进行set操作了。
          
        先这样吧 能答上几个也行...
        
           
                
                        
        
        
        

        
        
        
    
   
          
          
