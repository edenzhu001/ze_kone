本文会java集合类的基本框架，接口结构和部分源码。先开个头，有些常用的集合类后面会有专节讲述。

如图：
    Collection.jpg、Collection_01.png、Collection_02.png

一、Collection接口
    Collection接口是最基本的集合接口，继承自Collection的“子接口”如List和Set。

    所有实现了Collection接口的类都必须提供两套标准的构造函数：一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，
    用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。并且要求实现基本的增删改查方法，并且需要能够转换为数组类型。

    其中很多方法很熟悉，源码如下：
    public interface Collection<E> extends Iterable<E> {
        // Query Operations
        int size();

        boolean isEmpty();

        boolean contains(Object o);

        Iterator<E> iterator();

        Object[] toArray();

        <T> T[] toArray(T[] a);

        boolean add(E e);

        boolean remove(Object o);

        boolean containsAll(Collection<?> c);

        boolean addAll(Collection<? extends E> c);

        boolean removeAll(Collection<?> c);

        default boolean removeIf(Predicate<? super E> filter) {
            Objects.requireNonNull(filter);
            boolean removed = false;
            final Iterator<E> each = iterator();
            while (each.hasNext()) {
                if (filter.test(each.next())) {
                    each.remove();
                    removed = true;
                }
            }
            return removed;
        }

        boolean retainAll(Collection<?> c);

        void clear();

        boolean equals(Object o);

        int hashCode();

        @Override
        default Spliterator<E> spliterator() {
            return Spliterators.spliterator(this, 0);
        }

        default Stream<E> stream() {
            return StreamSupport.stream(spliterator(), false);
        }

        default Stream<E> parallelStream() {
            return StreamSupport.stream(spliterator(), true);
        }
       }
       
     二、List接口【有序，精准控制】
        List接口为Collection直接接口。有序，即它用某种特定的插入顺序来维护元素顺序。
        用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。

        实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。
        
        1.ArrayList【动态数组，非同步】
          动态数组，允许插入null。初始容量为10，每次添加元素都会去检查容量，扩容比例为50%。最好是指定容量，避免每次检查，扩容操作。
          
          ArrayList擅长于随机访问。同时ArrayList是非同步的。
          
        2.LinkedList【双向链表，非同步】
        基本操作还有get，remove，insert方法在LinkedList的首部或尾部。
        LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。
        这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。
        LinkedList也是非同步的，线程不安全。
        
        解决ArrayList LinkedList 不同步方式：List list = Collections.aynchronizedList(new ArrayList());
        或 List list = Collections.aynchronizedList(new LinkedList());
        
        3.Vector
        和ArrayList类似，只有一点不同。Vector是线程安全的动态数组。
        
        4.Stack
        Stack继承自Vector，实现FiLO先进后出的堆栈。
        额外方法：push放入  pop获取  peek获取顶栈的元素 empty判断堆栈是否为空  search查找一个元素在堆栈的位置。
        Stack创建后是空栈。
        
      三、Set接口
        包含不重复元素，可以存在null。
        由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。
        
        实现了Set集合有EnumSet、HashSet、TreeSet。
        
        1.EnumSet 是枚举的专用Set。所有的元素都是枚举类型
        
        2.HashSet HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，
        所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。
            
     四、Map接口
        Map是由一系列键值对组成的集合，提供了key到Value的单向映射。没有继承Collection接口。
        key是唯一的，但value可以相同。
        实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。
        
        1.HashMap【哈希表数据结构】
        HashMap.Entry的源码它是一个单链表结构
        
        2.TreeMap 【red-black树数据结构】
        键以某种排序规则排序。
        内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口
        
        3.HashTable
        也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低
        
     五、Queue接口
        队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，
        主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。
        另一种队列则是双端队列，支持在头、尾两端插入和移除元素，
        主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。
        
    还有一些集合小抄，下次继续
        
