这次将详细的介绍这个ArrayList类。

回忆一下：
  Collection接口下有List、Set接口。List接口下有ArrayList/Vector/LinkedList。
  Set接口下有HashSet/TreeSet。Queue接口下有LinkedList等。
  
  Map接口下有HashMap/HashTable/TreeMap。
  
  集合是java最基础重要的内容。集合的作用是以一定的方式组织、存储数据。
  Vector是线程安全的ArrayList。Stack继承自Vector。他们三者有相同的数据结构，
  都是数组实现的。
  
  探究集合从以下几点：思路方式
  (1)底层数据结构
  (2)增删改查方式
  (3)初始容量 扩容方式 扩容时机
  (4)线程安全与否
  (5)是否允许为空 是否允许重复 是否有序
  
  arrayList是动态数组，动态就是大小是可变的。可以存储null元素。

  每个arrayList的初始容量为10。扩容机制：每次添加元素时，都会检查是否需要扩容，扩容操作是数据向新数组的重新拷贝。
  所以，初始化指定容量大小，可以避免很多扩容拷贝问题和性能消耗。

  ArrayList是不同步的，线程不安全。防止意外对列表进行不同步的访问：List list = Collections.synchronizedList(new ArrayList<>(0));
  
  好，正式开始。加油啊，你还很菜啊。菜鸡。
  
  ArrayList简介
    底层是动态数组，容量动态增长。
    大家都知道既然是动态增长，那就是随着往ArrayList中添加元素，其容量也会自动增长。自动增长会带来数据向新数组的重新拷贝(每当向数组中添加元素时，都要去检查
    添加后的元素个数是否会超过当前数组的长度，如果超过，数据将进行扩容，以满足添加数据的需求，而每次数组容量的增长大约是其原容量的1.5倍);
    所以 ，代价其实是很高的。
    解决办法:
      可以预知数据量的前提下,(1) 可在构造ArrayList时指定其容量 
                                new ArrayList(100);
                           (2) 手动使用ensureCapacity操作来增加ArrayList实例的容量。可以减少递增式再分配的数量。
                                list = new ArrayList();
                                list.ensureCapacity(capacity);// 预先设置list大小(实际容量)
    ArrayList继承于AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable接口。
    
    ArrayList 线性表是顺序存储，插入删除元素的时间复杂度为O(n)，求  表长、增加元素、取第i个元素的时间复杂度为O(1)
    
    ArrayList extends AbstractList 表示 它是数组队列，有相关的添加 删除 修改 遍历等功能
    ArrayList implements RandomAccess ，【RandomAccess】是一个标志接口，表示实现这个接口的List集合是支持 【快速随机访问】的。
        我们可以通过元素序号获取到元素就是 【快速随机访问】
    ArrayList implements Cloneable接口，即覆盖了clone()，能【被克隆】。
    ArrayList implements java.io.Serializable接口，这意味着ArrayList支持【序列化】，能通过序列化去传输。
    
    和Vector不同，ArrayList中的操作是线程不安全的。所以，在单线程中使用ArrayList，多线程中可以选择Vector或CopyOnWriteArrayList。
    
    ArrayList核心代码
      /************************************************************************************************/
      package java.util;

      import java.util.function.Consumer;
      import java.util.function.Predicate;
      import java.util.function.UnaryOperator;

      public class ArrayList<E> extends AbstractList<E>
              implements List<E>, RandomAccess, Cloneable, java.io.Serializable
      {
          private static final long serialVersionUID = 8683452581122892189L;

          /**
           * 默认初始容量大小
           */
          private static final int DEFAULT_CAPACITY = 10;

          /**
           * 空数组应用于空实例
           */
          private static final Object[] EMPTY_ELEMENTDATA = {};

          /**
           *  用于默认大小空实例的共享空数组
           *  我们把它跟 EMPTY_ELEMENTDATA区分开来，便于知道在添加第一个元素时容量需要增加多少。
           */
          private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

          /**
           * 存储ArrayList元素的数组缓冲区。
           * 数组的容量是这个缓冲区的长度。
           * 当添加第一个元素时，elementData和默认容量空数组相等的列表
           * 将被拓展为默认长度10。
           */
          transient Object[] elementData; // non-private to simplify nested class access

          /**
           *  ArrayList包含元素个数
           * @serial
           */
          private int size;

          /**
           * 带初始容量参数的构造函数。（用户自己指定容量）
           *
           * @param  指定容量大小
           * @throws 参数异常
           */
          public ArrayList(int initialCapacity) {
              if (initialCapacity > 0) {
                  this.elementData = new Object[initialCapacity];
              } else if (initialCapacity == 0) {
                  this.elementData = EMPTY_ELEMENTDATA;
              } else {
                  throw new IllegalArgumentException("Illegal Capacity: "+
                                                     initialCapacity);
              }
          }

          /**
           * 默认构造函数，默认大小的空数组
           */
          public ArrayList() {
              this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
          }

          /**
           * 构造方法，包含一个集合的元素，这些元素是从集合中遍历出来的。
           *
           * @param collection c 
           * @throws 空指针
           */
          public ArrayList(Collection<? extends E> c) {
              elementData = c.toArray();
              //如果指定集合元素个数不为0
              if ((size = elementData.length) != 0) {
                  // c.toArray 可能返回的不是Object类型的数组，所以反射判断，反射里面的getClass()方法
                  if (elementData.getClass() != Object[].class)
                      elementData = Arrays.copyOf(elementData, size, Object[].class);
              } else {
                  // 若为0 则用空数组代替
                  this.elementData = EMPTY_ELEMENTDATA;
              }
          }

          /**
           * 修改这个ArrayList实例的容量，修改为是列表的当前元素个数(size)。 
           * 应用程序可以使用此操作来最小化ArrayList实例的存储容量。 
           */
          public void trimToSize() {
              modCount++;
              // 元素个数 < 数组长度
              if (size < elementData.length) {
                  elementData = (size == 0)
                    ? EMPTY_ELEMENTDATA
                    : Arrays.copyOf(elementData, size); // 直接生成指定元素个数的大小容量的数组
              }
          }

          /**
           * ArrayList的扩容机制
           * 如果每次只扩充一个，那么频繁的插入会导致频繁的拷贝，降低性能。
           * 扩容机制避免了这个问题
           *
           * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量
           * @param  所需的最小容量
           */
          public void ensureCapacity(int minCapacity) {
              int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                  // any size if not default element table
                  ? 0
                  // larger than default for default empty table. It's already
                  // supposed to be at default size.
                  : DEFAULT_CAPACITY;

              if (minCapacity > minExpand) {
                  // 确定显式容量
                  ensureExplicitCapacity(minCapacity);
              }
          }

          // 得到最小扩容量
          private void ensureCapacityInternal(int minCapacity) {
              // 若数组=默认容量空数组，则取默认值和入参的最大值作为最小值。
              if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
                  minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
              }
              // 否则直接用入参做最小值
              ensureExplicitCapacity(minCapacity);
          }

          // 确定是否需要扩容
          private void ensureExplicitCapacity(int minCapacity) {
              modCount++;

              // overflow-conscious code  入参设置最小容量 > 当前数组的长度，则扩容
              if (minCapacity - elementData.length > 0)
                  //调用grow方法进行扩容，调用此方法代表已经开始扩容了
                  grow(minCapacity);
          }

          /**
           *  要分配的最大数组大小
           */
          private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

          /**
           * 扩容核心方法
           */
          private void grow(int minCapacity) {
              // 当前数组的长度，即旧容量
              int oldCapacity = elementData.length;
              // 新容量
              // 将oldCapacity 右移一位，其效果相当于oldCapacity /2，
              // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
              int newCapacity = oldCapacity + (oldCapacity >> 1);
              
              // 然后检查【新容量】 < 【入参需要最小容量】，若是，取入参需要最小容量为新容量。反正取大值。
              if (newCapacity - minCapacity < 0)
                  newCapacity = minCapacity;
              
              //再检查【新容量】 是否超出了ArrayList所定义的最大容量，若超出，要么是Integer.Max_VALUE  -8 ，要么是Interger.MAX_VALUE
              if (newCapacity - MAX_ARRAY_SIZE > 0) 
                  newCapacity = hugeCapacity(minCapacity); 
              
              // 重新复制生成新数组，设置新容量
              elementData = Arrays.copyOf(elementData, newCapacity);
          }
          
          // 返回 Integer.MAX_VALUE 或 Integer.MAX_VALUE - 8；大容量
          private static int hugeCapacity(int minCapacity) {
              if (minCapacity < 0) // overflow
                  throw new OutOfMemoryError();
              return (minCapacity > MAX_ARRAY_SIZE) ?
                  Integer.MAX_VALUE :
                  MAX_ARRAY_SIZE;
          }

          /**
           * 返回数组中的元素数量
           */
          public int size() {
              return size;
          }

          /**
           * 如果数组中没有元素 则返回true
           */
          public boolean isEmpty() {
              return size == 0;
          }

          /**
           * 如果此列表包含指定的元素，则返回true 。
           */
          public boolean contains(Object o) {
              return indexOf(o) >= 0;
          }

          /**
           * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 。
           * 循环数组去查
           */
          public int indexOf(Object o) {
              if (o == null) {
                  for (int i = 0; i < size; i++)
                      if (elementData[i]==null)
                          return i;
              } else {
                  for (int i = 0; i < size; i++)
                      if (o.equals(elementData[i]))
                          return i;
              }
              return -1;
          }

          /**
           * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.
           */
          public int lastIndexOf(Object o) {
              if (o == null) {
                  for (int i = size-1; i >= 0; i--)
                      if (elementData[i]==null)
                          return i;
              } else {
                  for (int i = size-1; i >= 0; i--)
                      if (o.equals(elementData[i]))
                          return i;
              }
              return -1;
          }

          /**
           * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）
           */
          public Object clone() {
              try {
                  ArrayList<?> v = (ArrayList<?>) super.clone();
                  
                  // Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度
                  v.elementData = Arrays.copyOf(elementData, size);
                  v.modCount = 0;
                  return v;
              } catch (CloneNotSupportedException e) {
                  // 这不应该发生，因为我们是可以克隆的
                  throw new InternalError(e);
              }
          }

          /**
           * 以正确的顺序(从第一个到最后一个)返回一个包含列表中所有元素的数组
           *
           * 返回的数组将是安全的，列表不会保留对它的引用。因为返回的不是一个引用，而是返回的是新数组。
           * 调用者可以自由的修改返回的数组。
           *
           * 此方法是 基于阵列 和 基于集合的API之间的桥梁
           */
          public Object[] toArray() {
              return Arrays.copyOf(elementData, size);
          }

          /**
           * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;  
           * 
           * 如果当前传入的数组的长度 < 当前list的长度，就直接返回新数组。
           *如果传入的数组长度大于list长度，list的元素复制进来了。数组后面的元素从size开始，都是 null 了
           *
           * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
           *
           * 一般在需要将List转成Array的时候，都是调用 Bean arr[] = list.toArray(new Bean[0]);
           */
          @SuppressWarnings("unchecked")
          public <T> T[] toArray(T[] a) {
              if (a.length < size)
                  // Make a new array of a's runtime type, but my contents:
                  return (T[]) Arrays.copyOf(elementData, size, a.getClass());
              System.arraycopy(elementData, 0, a, 0, size);
              if (a.length > size)
                  a[size] = null;
              return a;
          }

          // Positional Access Operations

          @SuppressWarnings("unchecked")
          E elementData(int index) {
              return (E) elementData[index];
          }

          /**
           * 返回此列表中指定位置的元素。
           */
          public E get(int index) {
              rangeCheck(index);

              return elementData(index);
          }

          /**
           *  用指定的元素替换此列表中指定位置的元素。 
           */
          public E set(int index, E element) {
              //对index进行界限检查
              rangeCheck(index);

              E oldValue = elementData(index);
              elementData[index] = element;
              //返回原来在这个位置的元素
              return oldValue;
          }

          /**
           *  将指定的元素追加到此列表的末尾。 
           *
           * @param e element to be appended to this list
           * @return <tt>true</tt> (as specified by {@link Collection#add})
           */
          public boolean add(E e) {
              ensureCapacityInternal(size + 1);  // Increments modCount!!
              //这里看到ArrayList添加元素的实质就相当于为数组赋值
              elementData[size++] = e;
              return true;
          }

          /**
           * 在此列表中的指定位置插入指定的元素。 
           * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
           * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
           */
          public void add(int index, E element) {
              rangeCheckForAdd(index);

              ensureCapacityInternal(size + 1);  // Increments modCount!!
              
              //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己。
              // 把index这个位置给空出来
              System.arraycopy(elementData, index, elementData, index + 1,
                               size - index);
              elementData[index] = element;
              size++;
          }

          /**
           * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 
           */
          public E remove(int index) {
              rangeCheck(index);

              modCount++;
              E oldValue = elementData(index);

              int numMoved = size - index - 1;
              if (numMoved > 0)
                  System.arraycopy(elementData, index+1, elementData, index,
                                   numMoved);
              elementData[--size] = null; // clear to let GC do its work
              // 从列表中删除的元素 
              return oldValue;
          }

          /**
           * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。
           * 返回true，如果此列表包含指定的元素
           */
          public boolean remove(Object o) {
              if (o == null) {
                  for (int index = 0; index < size; index++)
                      if (elementData[index] == null) {
                          fastRemove(index);
                          return true;
                      }
              } else {
                  for (int index = 0; index < size; index++)
                      if (o.equals(elementData[index])) {
                          fastRemove(index);
                          return true;
                      }
              }
              return false;
          }

          /*
           * 私有remove方法跳过了数组边界校验，不会返回被删除的元素。
           */
          private void fastRemove(int index) {
              modCount++;
              int numMoved = size - index - 1;
              if (numMoved > 0)
                  System.arraycopy(elementData, index+1, elementData, index,
                                   numMoved);
              elementData[--size] = null; // clear to let GC do its work
          }

          /**
           * 从列表中删除所有元素。
           */
          public void clear() {
              modCount++;

              // clear to let GC do its work
              for (int i = 0; i < size; i++)
                  // 把数组中所有的元素的值设为null
                  elementData[i] = null;

              size = 0;
          }

          /**
           * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。
           */
          public boolean addAll(Collection<? extends E> c) {
              Object[] a = c.toArray();
              int numNew = a.length;
              ensureCapacityInternal(size + numNew);  // Increments modCount
              System.arraycopy(a, 0, elementData, size, numNew);
              size += numNew;
              return numNew != 0;
          }

          /**
           * Inserts all of the elements in the specified collection into this
           * list, starting at the specified position.  Shifts the element
           * currently at that position (if any) and any subsequent elements to
           * the right (increases their indices).  The new elements will appear
           * in the list in the order that they are returned by the
           * specified collection's iterator.
           *
           * @param index index at which to insert the first element from the
           *              specified collection
           * @param c collection containing elements to be added to this list
           * @return <tt>true</tt> if this list changed as a result of the call
           * @throws IndexOutOfBoundsException {@inheritDoc}
           * @throws NullPointerException if the specified collection is null
           */
          public boolean addAll(int index, Collection<? extends E> c) {
              rangeCheckForAdd(index);

              Object[] a = c.toArray();
              int numNew = a.length;
              ensureCapacityInternal(size + numNew);  // Increments modCount

              int numMoved = size - index;
              if (numMoved > 0)
                  System.arraycopy(elementData, index, elementData, index + numNew,
                                   numMoved);

              System.arraycopy(a, 0, elementData, index, numNew);
              size += numNew;
              return numNew != 0;
          }

          /**
           * Removes from this list all of the elements whose index is between
           * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.
           * Shifts any succeeding elements to the left (reduces their index).
           * This call shortens the list by {@code (toIndex - fromIndex)} elements.
           * (If {@code toIndex==fromIndex}, this operation has no effect.)
           *
           * @throws IndexOutOfBoundsException if {@code fromIndex} or
           *         {@code toIndex} is out of range
           *         ({@code fromIndex < 0 ||
           *          fromIndex >= size() ||
           *          toIndex > size() ||
           *          toIndex < fromIndex})
           */
          protected void removeRange(int fromIndex, int toIndex) {
              modCount++;
              int numMoved = size - toIndex;
              System.arraycopy(elementData, toIndex, elementData, fromIndex,
                               numMoved);

              // clear to let GC do its work
              int newSize = size - (toIndex-fromIndex);
              for (int i = newSize; i < size; i++) {
                  elementData[i] = null;
              }
              size = newSize;
          }

          /**
           * Checks if the given index is in range.  If not, throws an appropriate
           * runtime exception.  This method does *not* check if the index is
           * negative: It is always used immediately prior to an array access,
           * which throws an ArrayIndexOutOfBoundsException if index is negative.
           */
          private void rangeCheck(int index) {
              if (index >= size)
                  throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
          }

          /**
           * A version of rangeCheck used by add and addAll.
           */
          private void rangeCheckForAdd(int index) {
              if (index > size || index < 0)
                  throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
          }

          /**
           * Constructs an IndexOutOfBoundsException detail message.
           * Of the many possible refactorings of the error handling code,
           * this "outlining" performs best with both server and client VMs.
           */
          private String outOfBoundsMsg(int index) {
              return "Index: "+index+", Size: "+size;
          }

          /**
           * Removes from this list all of its elements that are contained in the
           * specified collection.
           *
           * @param c collection containing elements to be removed from this list
           * @return {@code true} if this list changed as a result of the call
           * @throws ClassCastException if the class of an element of this list
           *         is incompatible with the specified collection
           * (<a href="Collection.html#optional-restrictions">optional</a>)
           * @throws NullPointerException if this list contains a null element and the
           *         specified collection does not permit null elements
           * (<a href="Collection.html#optional-restrictions">optional</a>),
           *         or if the specified collection is null
           * @see Collection#contains(Object)
           */
          public boolean removeAll(Collection<?> c) {
              Objects.requireNonNull(c);
              return batchRemove(c, false);
          }

          /**
           * Retains only the elements in this list that are contained in the
           * specified collection.  In other words, removes from this list all
           * of its elements that are not contained in the specified collection.
           *
           * @param c collection containing elements to be retained in this list
           * @return {@code true} if this list changed as a result of the call
           * @throws ClassCastException if the class of an element of this list
           *         is incompatible with the specified collection
           * (<a href="Collection.html#optional-restrictions">optional</a>)
           * @throws NullPointerException if this list contains a null element and the
           *         specified collection does not permit null elements
           * (<a href="Collection.html#optional-restrictions">optional</a>),
           *         or if the specified collection is null
           * @see Collection#contains(Object)
           */
          public boolean retainAll(Collection<?> c) {
              Objects.requireNonNull(c);
              return batchRemove(c, true);
          }

          private boolean batchRemove(Collection<?> c, boolean complement) {
              final Object[] elementData = this.elementData;
              int r = 0, w = 0;
              boolean modified = false;
              try {
                  for (; r < size; r++)
                      if (c.contains(elementData[r]) == complement)
                          elementData[w++] = elementData[r];
              } finally {
                  // Preserve behavioral compatibility with AbstractCollection,
                  // even if c.contains() throws.
                  if (r != size) {
                      System.arraycopy(elementData, r,
                                       elementData, w,
                                       size - r);
                      w += size - r;
                  }
                  if (w != size) {
                      // clear to let GC do its work
                      for (int i = w; i < size; i++)
                          elementData[i] = null;
                      modCount += size - w;
                      size = w;
                      modified = true;
                  }
              }
              return modified;
          }

          /**
           * Save the state of the <tt>ArrayList</tt> instance to a stream (that
           * is, serialize it).
           *
           * @serialData The length of the array backing the <tt>ArrayList</tt>
           *             instance is emitted (int), followed by all of its elements
           *             (each an <tt>Object</tt>) in the proper order.
           */
          private void writeObject(java.io.ObjectOutputStream s)
              throws java.io.IOException{
              // Write out element count, and any hidden stuff
              int expectedModCount = modCount;
              s.defaultWriteObject();

              // Write out size as capacity for behavioural compatibility with clone()
              s.writeInt(size);

              // Write out all elements in the proper order.
              for (int i=0; i<size; i++) {
                  s.writeObject(elementData[i]);
              }

              if (modCount != expectedModCount) {
                  throw new ConcurrentModificationException();
              }
          }

          /**
           * Reconstitute the <tt>ArrayList</tt> instance from a stream (that is,
           * deserialize it).
           */
          private void readObject(java.io.ObjectInputStream s)
              throws java.io.IOException, ClassNotFoundException {
              elementData = EMPTY_ELEMENTDATA;

              // Read in size, and any hidden stuff
              s.defaultReadObject();

              // Read in capacity
              s.readInt(); // ignored

              if (size > 0) {
                  // be like clone(), allocate array based upon size not capacity
                  ensureCapacityInternal(size);

                  Object[] a = elementData;
                  // Read in all elements in the proper order.
                  for (int i=0; i<size; i++) {
                      a[i] = s.readObject();
                  }
              }
          }

          /**
           * Returns a list iterator over the elements in this list (in proper
           * sequence), starting at the specified position in the list.
           * The specified index indicates the first element that would be
           * returned by an initial call to {@link ListIterator#next next}.
           * An initial call to {@link ListIterator#previous previous} would
           * return the element with the specified index minus one.
           *
           * <p>The returned list iterator is <a href="#fail-fast"><i>fail-fast</i></a>.
           *
           * @throws IndexOutOfBoundsException {@inheritDoc}
           */
          public ListIterator<E> listIterator(int index) {
              if (index < 0 || index > size)
                  throw new IndexOutOfBoundsException("Index: "+index);
              return new ListItr(index);
          }

          /**
           * Returns a list iterator over the elements in this list (in proper
           * sequence).
           *
           * <p>The returned list iterator is <a href="#fail-fast"><i>fail-fast</i></a>.
           *
           * @see #listIterator(int)
           */
          public ListIterator<E> listIterator() {
              return new ListItr(0);
          }

          /**
           * Returns an iterator over the elements in this list in proper sequence.
           *
           * <p>The returned iterator is <a href="#fail-fast"><i>fail-fast</i></a>.
           *
           * @return an iterator over the elements in this list in proper sequence
           */
          public Iterator<E> iterator() {
              return new Itr();
          }

          /**
           * An optimized version of AbstractList.Itr
           */
          private class Itr implements Iterator<E> {
              int cursor;       // index of next element to return
              int lastRet = -1; // index of last element returned; -1 if no such
              int expectedModCount = modCount;

              public boolean hasNext() {
                  return cursor != size;
              }

              @SuppressWarnings("unchecked")
              public E next() {
                  checkForComodification();
                  int i = cursor;
                  if (i >= size)
                      throw new NoSuchElementException();
                  Object[] elementData = ArrayList.this.elementData;
                  if (i >= elementData.length)
                      throw new ConcurrentModificationException();
                  cursor = i + 1;
                  return (E) elementData[lastRet = i];
              }

              public void remove() {
                  if (lastRet < 0)
                      throw new IllegalStateException();
                  checkForComodification();

                  try {
                      ArrayList.this.remove(lastRet);
                      cursor = lastRet;
                      lastRet = -1;
                      expectedModCount = modCount;
                  } catch (IndexOutOfBoundsException ex) {
                      throw new ConcurrentModificationException();
                  }
              }

              @Override
              @SuppressWarnings("unchecked")
              public void forEachRemaining(Consumer<? super E> consumer) {
                  Objects.requireNonNull(consumer);
                  final int size = ArrayList.this.size;
                  int i = cursor;
                  if (i >= size) {
                      return;
                  }
                  final Object[] elementData = ArrayList.this.elementData;
                  if (i >= elementData.length) {
                      throw new ConcurrentModificationException();
                  }
                  while (i != size && modCount == expectedModCount) {
                      consumer.accept((E) elementData[i++]);
                  }
                  // update once at end of iteration to reduce heap write traffic
                  cursor = i;
                  lastRet = i - 1;
                  checkForComodification();
              }

              final void checkForComodification() {
                  if (modCount != expectedModCount)
                      throw new ConcurrentModificationException();
              }
          }

          /**
           * An optimized version of AbstractList.ListItr
           */
          private class ListItr extends Itr implements ListIterator<E> {
              ListItr(int index) {
                  super();
                  cursor = index;
              }

              public boolean hasPrevious() {
                  return cursor != 0;
              }

              public int nextIndex() {
                  return cursor;
              }

              public int previousIndex() {
                  return cursor - 1;
              }

              @SuppressWarnings("unchecked")
              public E previous() {
                  checkForComodification();
                  int i = cursor - 1;
                  if (i < 0)
                      throw new NoSuchElementException();
                  Object[] elementData = ArrayList.this.elementData;
                  if (i >= elementData.length)
                      throw new ConcurrentModificationException();
                  cursor = i;
                  return (E) elementData[lastRet = i];
              }

              public void set(E e) {
                  if (lastRet < 0)
                      throw new IllegalStateException();
                  checkForComodification();

                  try {
                      ArrayList.this.set(lastRet, e);
                  } catch (IndexOutOfBoundsException ex) {
                      throw new ConcurrentModificationException();
                  }
              }

              public void add(E e) {
                  checkForComodification();

                  try {
                      int i = cursor;
                      ArrayList.this.add(i, e);
                      cursor = i + 1;
                      lastRet = -1;
                      expectedModCount = modCount;
                  } catch (IndexOutOfBoundsException ex) {
                      throw new ConcurrentModificationException();
                  }
              }
          }

          /**
           * Returns a view of the portion of this list between the specified
           * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
           * {@code fromIndex} and {@code toIndex} are equal, the returned list is
           * empty.)  The returned list is backed by this list, so non-structural
           * changes in the returned list are reflected in this list, and vice-versa.
           * The returned list supports all of the optional list operations.
           *
           * <p>This method eliminates the need for explicit range operations (of
           * the sort that commonly exist for arrays).  Any operation that expects
           * a list can be used as a range operation by passing a subList view
           * instead of a whole list.  For example, the following idiom
           * removes a range of elements from a list:
           * <pre>
           *      list.subList(from, to).clear();
           * </pre>
           * Similar idioms may be constructed for {@link #indexOf(Object)} and
           * {@link #lastIndexOf(Object)}, and all of the algorithms in the
           * {@link Collections} class can be applied to a subList.
           *
           * <p>The semantics of the list returned by this method become undefined if
           * the backing list (i.e., this list) is <i>structurally modified</i> in
           * any way other than via the returned list.  (Structural modifications are
           * those that change the size of this list, or otherwise perturb it in such
           * a fashion that iterations in progress may yield incorrect results.)
           *
           * @throws IndexOutOfBoundsException {@inheritDoc}
           * @throws IllegalArgumentException {@inheritDoc}
           */
          public List<E> subList(int fromIndex, int toIndex) {
              subListRangeCheck(fromIndex, toIndex, size);
              return new SubList(this, 0, fromIndex, toIndex);
          }

          static void subListRangeCheck(int fromIndex, int toIndex, int size) {
              if (fromIndex < 0)
                  throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
              if (toIndex > size)
                  throw new IndexOutOfBoundsException("toIndex = " + toIndex);
              if (fromIndex > toIndex)
                  throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                                     ") > toIndex(" + toIndex + ")");
          }

          private class SubList extends AbstractList<E> implements RandomAccess {
              private final AbstractList<E> parent;
              private final int parentOffset;
              private final int offset;
              int size;

              SubList(AbstractList<E> parent,
                      int offset, int fromIndex, int toIndex) {
                  this.parent = parent;
                  this.parentOffset = fromIndex;
                  this.offset = offset + fromIndex;
                  this.size = toIndex - fromIndex;
                  this.modCount = ArrayList.this.modCount;
              }

              public E set(int index, E e) {
                  rangeCheck(index);
                  checkForComodification();
                  E oldValue = ArrayList.this.elementData(offset + index);
                  ArrayList.this.elementData[offset + index] = e;
                  return oldValue;
              }

              public E get(int index) {
                  rangeCheck(index);
                  checkForComodification();
                  return ArrayList.this.elementData(offset + index);
              }

              public int size() {
                  checkForComodification();
                  return this.size;
              }

              public void add(int index, E e) {
                  rangeCheckForAdd(index);
                  checkForComodification();
                  parent.add(parentOffset + index, e);
                  this.modCount = parent.modCount;
                  this.size++;
              }

              public E remove(int index) {
                  rangeCheck(index);
                  checkForComodification();
                  E result = parent.remove(parentOffset + index);
                  this.modCount = parent.modCount;
                  this.size--;
                  return result;
              }

              protected void removeRange(int fromIndex, int toIndex) {
                  checkForComodification();
                  parent.removeRange(parentOffset + fromIndex,
                                     parentOffset + toIndex);
                  this.modCount = parent.modCount;
                  this.size -= toIndex - fromIndex;
              }

              public boolean addAll(Collection<? extends E> c) {
                  return addAll(this.size, c);
              }

              public boolean addAll(int index, Collection<? extends E> c) {
                  rangeCheckForAdd(index);
                  int cSize = c.size();
                  if (cSize==0)
                      return false;

                  checkForComodification();
                  parent.addAll(parentOffset + index, c);
                  this.modCount = parent.modCount;
                  this.size += cSize;
                  return true;
              }

              public Iterator<E> iterator() {
                  return listIterator();
              }

              public ListIterator<E> listIterator(final int index) {
                  checkForComodification();
                  rangeCheckForAdd(index);
                  final int offset = this.offset;

                  return new ListIterator<E>() {
                      int cursor = index;
                      int lastRet = -1;
                      int expectedModCount = ArrayList.this.modCount;

                      public boolean hasNext() {
                          return cursor != SubList.this.size;
                      }

                      @SuppressWarnings("unchecked")
                      public E next() {
                          checkForComodification();
                          int i = cursor;
                          if (i >= SubList.this.size)
                              throw new NoSuchElementException();
                          Object[] elementData = ArrayList.this.elementData;
                          if (offset + i >= elementData.length)
                              throw new ConcurrentModificationException();
                          cursor = i + 1;
                          return (E) elementData[offset + (lastRet = i)];
                      }

                      public boolean hasPrevious() {
                          return cursor != 0;
                      }

                      @SuppressWarnings("unchecked")
                      public E previous() {
                          checkForComodification();
                          int i = cursor - 1;
                          if (i < 0)
                              throw new NoSuchElementException();
                          Object[] elementData = ArrayList.this.elementData;
                          if (offset + i >= elementData.length)
                              throw new ConcurrentModificationException();
                          cursor = i;
                          return (E) elementData[offset + (lastRet = i)];
                      }

                      @SuppressWarnings("unchecked")
                      public void forEachRemaining(Consumer<? super E> consumer) {
                          Objects.requireNonNull(consumer);
                          final int size = SubList.this.size;
                          int i = cursor;
                          if (i >= size) {
                              return;
                          }
                          final Object[] elementData = ArrayList.this.elementData;
                          if (offset + i >= elementData.length) {
                              throw new ConcurrentModificationException();
                          }
                          while (i != size && modCount == expectedModCount) {
                              consumer.accept((E) elementData[offset + (i++)]);
                          }
                          // update once at end of iteration to reduce heap write traffic
                          lastRet = cursor = i;
                          checkForComodification();
                      }

                      public int nextIndex() {
                          return cursor;
                      }

                      public int previousIndex() {
                          return cursor - 1;
                      }

                      public void remove() {
                          if (lastRet < 0)
                              throw new IllegalStateException();
                          checkForComodification();

                          try {
                              SubList.this.remove(lastRet);
                              cursor = lastRet;
                              lastRet = -1;
                              expectedModCount = ArrayList.this.modCount;
                          } catch (IndexOutOfBoundsException ex) {
                              throw new ConcurrentModificationException();
                          }
                      }

                      public void set(E e) {
                          if (lastRet < 0)
                              throw new IllegalStateException();
                          checkForComodification();

                          try {
                              ArrayList.this.set(offset + lastRet, e);
                          } catch (IndexOutOfBoundsException ex) {
                              throw new ConcurrentModificationException();
                          }
                      }

                      public void add(E e) {
                          checkForComodification();

                          try {
                              int i = cursor;
                              SubList.this.add(i, e);
                              cursor = i + 1;
                              lastRet = -1;
                              expectedModCount = ArrayList.this.modCount;
                          } catch (IndexOutOfBoundsException ex) {
                              throw new ConcurrentModificationException();
                          }
                      }

                      final void checkForComodification() {
                          if (expectedModCount != ArrayList.this.modCount)
                              throw new ConcurrentModificationException();
                      }
                  };
              }

              public List<E> subList(int fromIndex, int toIndex) {
                  subListRangeCheck(fromIndex, toIndex, size);
                  return new SubList(this, offset, fromIndex, toIndex);
              }

              private void rangeCheck(int index) {
                  if (index < 0 || index >= this.size)
                      throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
              }

              private void rangeCheckForAdd(int index) {
                  if (index < 0 || index > this.size)
                      throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
              }

              private String outOfBoundsMsg(int index) {
                  return "Index: "+index+", Size: "+this.size;
              }

              private void checkForComodification() {
                  if (ArrayList.this.modCount != this.modCount)
                      throw new ConcurrentModificationException();
              }

              public Spliterator<E> spliterator() {
                  checkForComodification();
                  return new ArrayListSpliterator<E>(ArrayList.this, offset,
                                                     offset + this.size, this.modCount);
              }
          }

          @Override
          public void forEach(Consumer<? super E> action) {
              Objects.requireNonNull(action);
              final int expectedModCount = modCount;
              @SuppressWarnings("unchecked")
              final E[] elementData = (E[]) this.elementData;
              final int size = this.size;
              for (int i=0; modCount == expectedModCount && i < size; i++) {
                  action.accept(elementData[i]);
              }
              if (modCount != expectedModCount) {
                  throw new ConcurrentModificationException();
              }
          }

          /**
           * Creates a <em><a href="Spliterator.html#binding">late-binding</a></em>
           * and <em>fail-fast</em> {@link Spliterator} over the elements in this
           * list.
           *
           * <p>The {@code Spliterator} reports {@link Spliterator#SIZED},
           * {@link Spliterator#SUBSIZED}, and {@link Spliterator#ORDERED}.
           * Overriding implementations should document the reporting of additional
           * characteristic values.
           *
           * @return a {@code Spliterator} over the elements in this list
           * @since 1.8
           */
          @Override
          public Spliterator<E> spliterator() {
              return new ArrayListSpliterator<>(this, 0, -1, 0);
          }

          /** Index-based split-by-two, lazily initialized Spliterator */
          static final class ArrayListSpliterator<E> implements Spliterator<E> {

              /*
               * If ArrayLists were immutable, or structurally immutable (no
               * adds, removes, etc), we could implement their spliterators
               * with Arrays.spliterator. Instead we detect as much
               * interference during traversal as practical without
               * sacrificing much performance. We rely primarily on
               * modCounts. These are not guaranteed to detect concurrency
               * violations, and are sometimes overly conservative about
               * within-thread interference, but detect enough problems to
               * be worthwhile in practice. To carry this out, we (1) lazily
               * initialize fence and expectedModCount until the latest
               * point that we need to commit to the state we are checking
               * against; thus improving precision.  (This doesn't apply to
               * SubLists, that create spliterators with current non-lazy
               * values).  (2) We perform only a single
               * ConcurrentModificationException check at the end of forEach
               * (the most performance-sensitive method). When using forEach
               * (as opposed to iterators), we can normally only detect
               * interference after actions, not before. Further
               * CME-triggering checks apply to all other possible
               * violations of assumptions for example null or too-small
               * elementData array given its size(), that could only have
               * occurred due to interference.  This allows the inner loop
               * of forEach to run without any further checks, and
               * simplifies lambda-resolution. While this does entail a
               * number of checks, note that in the common case of
               * list.stream().forEach(a), no checks or other computation
               * occur anywhere other than inside forEach itself.  The other
               * less-often-used methods cannot take advantage of most of
               * these streamlinings.
               */

              private final ArrayList<E> list;
              private int index; // current index, modified on advance/split
              private int fence; // -1 until used; then one past last index
              private int expectedModCount; // initialized when fence set

              /** Create new spliterator covering the given  range */
              ArrayListSpliterator(ArrayList<E> list, int origin, int fence,
                                   int expectedModCount) {
                  this.list = list; // OK if null unless traversed
                  this.index = origin;
                  this.fence = fence;
                  this.expectedModCount = expectedModCount;
              }

              private int getFence() { // initialize fence to size on first use
                  int hi; // (a specialized variant appears in method forEach)
                  ArrayList<E> lst;
                  if ((hi = fence) < 0) {
                      if ((lst = list) == null)
                          hi = fence = 0;
                      else {
                          expectedModCount = lst.modCount;
                          hi = fence = lst.size;
                      }
                  }
                  return hi;
              }

              public ArrayListSpliterator<E> trySplit() {
                  int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;
                  return (lo >= mid) ? null : // divide range in half unless too small
                      new ArrayListSpliterator<E>(list, lo, index = mid,
                                                  expectedModCount);
              }

              public boolean tryAdvance(Consumer<? super E> action) {
                  if (action == null)
                      throw new NullPointerException();
                  int hi = getFence(), i = index;
                  if (i < hi) {
                      index = i + 1;
                      @SuppressWarnings("unchecked") E e = (E)list.elementData[i];
                      action.accept(e);
                      if (list.modCount != expectedModCount)
                          throw new ConcurrentModificationException();
                      return true;
                  }
                  return false;
              }

              public void forEachRemaining(Consumer<? super E> action) {
                  int i, hi, mc; // hoist accesses and checks from loop
                  ArrayList<E> lst; Object[] a;
                  if (action == null)
                      throw new NullPointerException();
                  if ((lst = list) != null && (a = lst.elementData) != null) {
                      if ((hi = fence) < 0) {
                          mc = lst.modCount;
                          hi = lst.size;
                      }
                      else
                          mc = expectedModCount;
                      if ((i = index) >= 0 && (index = hi) <= a.length) {
                          for (; i < hi; ++i) {
                              @SuppressWarnings("unchecked") E e = (E) a[i];
                              action.accept(e);
                          }
                          if (lst.modCount == mc)
                              return;
                      }
                  }
                  throw new ConcurrentModificationException();
              }

              public long estimateSize() {
                  return (long) (getFence() - index);
              }

              public int characteristics() {
                  return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
              }
          }

          @Override
          public boolean removeIf(Predicate<? super E> filter) {
              Objects.requireNonNull(filter);
              // figure out which elements are to be removed
              // any exception thrown from the filter predicate at this stage
              // will leave the collection unmodified
              int removeCount = 0;
              final BitSet removeSet = new BitSet(size);
              final int expectedModCount = modCount;
              final int size = this.size;
              for (int i=0; modCount == expectedModCount && i < size; i++) {
                  @SuppressWarnings("unchecked")
                  final E element = (E) elementData[i];
                  if (filter.test(element)) {
                      removeSet.set(i);
                      removeCount++;
                  }
              }
              if (modCount != expectedModCount) {
                  throw new ConcurrentModificationException();
              }

              // shift surviving elements left over the spaces left by removed elements
              final boolean anyToRemove = removeCount > 0;
              if (anyToRemove) {
                  final int newSize = size - removeCount;
                  for (int i=0, j=0; (i < size) && (j < newSize); i++, j++) {
                      i = removeSet.nextClearBit(i);
                      elementData[j] = elementData[i];
                  }
                  for (int k=newSize; k < size; k++) {
                      elementData[k] = null;  // Let gc do its work
                  }
                  this.size = newSize;
                  if (modCount != expectedModCount) {
                      throw new ConcurrentModificationException();
                  }
                  modCount++;
              }

              return anyToRemove;
          }

          @Override
          @SuppressWarnings("unchecked")
          public void replaceAll(UnaryOperator<E> operator) {
              Objects.requireNonNull(operator);
              final int expectedModCount = modCount;
              final int size = this.size;
              for (int i=0; modCount == expectedModCount && i < size; i++) {
                  elementData[i] = operator.apply((E) elementData[i]);
              }
              if (modCount != expectedModCount) {
                  throw new ConcurrentModificationException();
              }
              modCount++;
          }

          @Override
          @SuppressWarnings("unchecked")
          public void sort(Comparator<? super E> c) {
              final int expectedModCount = modCount;
              Arrays.sort((E[]) elementData, 0, size, c);
              if (modCount != expectedModCount) {
                  throw new ConcurrentModificationException();
              }
              modCount++;
          }
      }
      /************************************************************************************************/
    
    
  
  
